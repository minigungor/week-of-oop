ООП: Что это такое, как и для чего:

Какие парадигмы программирования бывают
Отход от процедурного программирования к ООП
Кому и как объекты упрощают жизнь, а кому усложняют
Как придумывали объектно-ориентированную парадигму
Чем удобнее пользовательские типы и структуры данных
Динамическая память, указатели и сборщик мусора
Передача по ссылке и по значению


a := 5;
print sin(a);

реальный мир
M - ActiveRecord
V - Views
C - Controllers

---------------

Вася  ->  расходБензина(...)
Петя  ->  другойРасходБензина(..., ...)

-----------------

Может ли кривой строитель из кривых кирпичей собрать ровный дом? или двигатель?
    нет
А из ровных кирпичей?
    нет или сильно постарается
а хороший мастер из кривых?
    да, но неудобно
а хороший из ровных?
    да
------------------
важен мастер
Мы будет изучать мастерство, а на каком языке, на каком фреймворке, в какой парадигме - это не важно

==============

какие парадигмы программирования бывают

---

Императив

бездумный исполнитель
-----------

императивное программирование

Как сделать?

a := 5;
b := 12;
c := a + b;
print c;

Открой фотошоп
создай документ
залей фон
Открой фотошоп
создай документ
залей фон
Открой фотошоп
создай документ
залей фон

--------
декларативное программирование

что сделать?

SELECT name FROM user ORDER BY name LIMIT 10; 'дай имена пользователей'

'Сделай дизаин по такому макету' ..... дизайн

sum(5,3)

print расходБензина(250, 12, a, b, t1, t2)

ЗагрузиИменаПользователейССортировкой(10, 'name')

-------------------

Структурное программирование

a := 5;
b := 12;
c := a + b;
a := 5;
b := 12;
c := a + b;
a := 5;
b := 12;
c := a + b;
a := 5;
b := 12;
c := a + b;
a := 5;
b := 12;
c := a + b;
a := 5;
b := 12;
c := a + b;

goto

a := 5;
b := 12;
c := a + b;
let 5;
a := 5;
b := 12;
if(b >= 12) {
    goto 12;
}
c := a + b;
a := 5;
b := 12;
if(a > 5) {
    goto 5;
}
c := a + b;
a := 5;
let 12;
b := 12;
c := a + b;

Принципы:
- Отказ от условного оператора goto;
- любая программа состоит из 3 базовых конструкций: последовательность, ветвление, цикл
- конструкции могут быть вложены в друг друга
- Каждую законченную логическую группу инструкции следует оформить как блок.
- Все конструкции должны иметь 1 вход 1 выход
- Разработка программ идет пошагово образом "сверху вниз"

procedure init() {
    ...
}

function process() {
    if(...) {
        b := 7;
        c = a + b;
        for(...) {
            if(...) {
            c = a + b;
            }
        }
    } else {
        b = 7;
        c = 16;
    }
}

init();
a := process();
export(a);

======================
-> [] -> [] -> [] -> [] -> []


----

Процедурное программирование (подход)
    разнесение кода по процедурам и функциям

students = loadStudentsFromFile($file);
filtereds = [];
result = '';
foreach(students as student) {
    if(isOchn(student)){
        filtereds[] = student;
    }
}
foreach(filtereds as filtered) {
    result = result + ', ' + getFullName(filtered);
}
print result;

--------------------------------------------------------------------------------------
    Функциональное программирование     |   Объектно-ориентированное программирование
--------------------------------------------------------------------------------------

print
    reduce(
        join(', ',
            map(getFullname,
                filter(isOchn,
                    loadStudentsFromFile(file)))))


function map($func, $items) {
    $result = [];
    foreach(items as item) {
        $result[] = func(item);
    }
    return $result;
}

$items = [2, 5, 3, 16, 7];

$square = function($a) {
    return $a * $a;
}

print_r(array_map($square, $items)); /[4, 25, 9 ...]

function map($func, $items) {
    $result = [];
    foreach(items as item) {
        $result[] = func(item);
    }
    return $result;
}

--------------

function map($func, $items) {
    if(count($items) > 1) {
        return array_merge(
            [$func(reset($items))],
             map($func, array_slice($items, 1))
         ); // 4
    } else {
        return items;
    }
}

-----------------------

- Лапшекод
- Процедуры облегчили лапшекод
- нудобство сотен процедур
- разрозненность данных
- компоновка по смыслу

-----------------------

$отделКадров->нанятьСотрудника($ДанныеСотрудника);

-----------------------

Хорошее ООП
    Разгружает голову
    привносить модульность
    повышает совместимость
    локализует изменения
    абстрагируется от реализации
    упрощает код
    легко тестируется

Недо-ООП
    Привносит сложность
    сохраняет процедурный подход
    причиняет неудобство
    Т.е никакой пользы не привносит

Недо ООП